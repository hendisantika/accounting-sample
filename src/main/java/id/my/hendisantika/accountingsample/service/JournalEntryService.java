package id.my.hendisantika.accountingsample.service;

import id.my.hendisantika.accountingsample.dto.journal.JournalEntryRequest;
import id.my.hendisantika.accountingsample.dto.journal.JournalEntryResponse;
import id.my.hendisantika.accountingsample.exception.BusinessException;
import id.my.hendisantika.accountingsample.exception.ResourceNotFoundException;
import id.my.hendisantika.accountingsample.model.Account;
import id.my.hendisantika.accountingsample.model.JournalEntry;
import id.my.hendisantika.accountingsample.model.JournalEntryLine;
import id.my.hendisantika.accountingsample.model.Organization;
import id.my.hendisantika.accountingsample.model.enums.JournalEntryStatus;
import id.my.hendisantika.accountingsample.repository.AccountRepository;
import id.my.hendisantika.accountingsample.repository.JournalEntryRepository;
import id.my.hendisantika.accountingsample.repository.OrganizationRepository;
import id.my.hendisantika.accountingsample.util.SecurityUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Created by IntelliJ IDEA.
 * Project : accounting-sample
 * User: hendisantika
 * Link: s.id/hendisantika
 * Email: hendisantika@yahoo.co.id
 * Telegram : @hendisantika34
 * Date: 16/10/25
 * Time: 13.45
 * To change this template use File | Settings | File Templates.
 */
@Service
@RequiredArgsConstructor
public class JournalEntryService {

    private final JournalEntryRepository journalEntryRepository;
    private final AccountRepository accountRepository;
    private final OrganizationRepository organizationRepository;

    @Transactional(readOnly = true)
    public List<JournalEntryResponse> getAllJournalEntries() {
        Long orgId = SecurityUtils.getCurrentOrganizationId();
        return journalEntryRepository.findByOrganizationId(orgId).stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<JournalEntryResponse> getJournalEntriesByStatus(JournalEntryStatus status) {
        Long orgId = SecurityUtils.getCurrentOrganizationId();
        return journalEntryRepository.findByStatusAndOrganizationId(status, orgId).stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public JournalEntryResponse getJournalEntryById(Long id) {
        Long orgId = SecurityUtils.getCurrentOrganizationId();
        JournalEntry journalEntry = journalEntryRepository.findByIdAndOrganizationId(id, orgId)
                .orElseThrow(() -> new ResourceNotFoundException("Journal entry not found"));
        return mapToResponse(journalEntry);
    }

    @Transactional
    public JournalEntryResponse createJournalEntry(JournalEntryRequest request) {
        Long orgId = SecurityUtils.getCurrentOrganizationId();

        // Check if journal number already exists
        if (journalEntryRepository.existsByJournalNumberAndOrganizationId(request.getJournalNumber(), orgId)) {
            throw new BusinessException("Journal number already exists");
        }

        Organization organization = organizationRepository.findById(orgId)
                .orElseThrow(() -> new ResourceNotFoundException("Organization not found"));

        JournalEntry journalEntry = JournalEntry.builder()
                .organization(organization)
                .journalNumber(request.getJournalNumber())
                .entryDate(request.getEntryDate())
                .status(JournalEntryStatus.DRAFT)
                .reference(request.getReference())
                .description(request.getDescription())
                .isAutoGenerated(false)
                .build();

        // Create lines
        List<JournalEntryLine> lines = new ArrayList<>();
        BigDecimal totalDebit = BigDecimal.ZERO;
        BigDecimal totalCredit = BigDecimal.ZERO;

        for (var lineRequest : request.getLines()) {
            Account account = accountRepository.findByIdAndOrganizationId(lineRequest.getAccountId(), orgId)
                    .orElseThrow(() -> new ResourceNotFoundException("Account not found: " + lineRequest.getAccountId()));

            JournalEntryLine line = JournalEntryLine.builder()
                    .journalEntry(journalEntry)
                    .account(account)
                    .description(lineRequest.getDescription())
                    .debitAmount(lineRequest.getDebitAmount() != null ? lineRequest.getDebitAmount() : BigDecimal.ZERO)
                    .creditAmount(lineRequest.getCreditAmount() != null ? lineRequest.getCreditAmount() : BigDecimal.ZERO)
                    .lineOrder(lineRequest.getLineOrder())
                    .build();

            lines.add(line);
            totalDebit = totalDebit.add(line.getDebitAmount());
            totalCredit = totalCredit.add(line.getCreditAmount());
        }

        journalEntry.setLines(lines);
        journalEntry.setTotalDebit(totalDebit);
        journalEntry.setTotalCredit(totalCredit);

        // Validate double entry
        validateDoubleEntry(journalEntry);

        journalEntry = journalEntryRepository.save(journalEntry);
        return mapToResponse(journalEntry);
    }

    @Transactional
    public JournalEntryResponse updateJournalEntry(Long id, JournalEntryRequest request) {
        Long orgId = SecurityUtils.getCurrentOrganizationId();
        JournalEntry journalEntry = journalEntryRepository.findByIdAndOrganizationId(id, orgId)
                .orElseThrow(() -> new ResourceNotFoundException("Journal entry not found"));

        // Only allow updates to DRAFT entries
        if (journalEntry.getStatus() != JournalEntryStatus.DRAFT) {
            throw new BusinessException("Cannot update journal entry that is not in DRAFT status");
        }

        // Check if new journal number already exists (if changed)
        if (!journalEntry.getJournalNumber().equals(request.getJournalNumber()) &&
                journalEntryRepository.existsByJournalNumberAndOrganizationId(request.getJournalNumber(), orgId)) {
            throw new BusinessException("Journal number already exists");
        }

        // Update basic fields
        journalEntry.setJournalNumber(request.getJournalNumber());
        journalEntry.setEntryDate(request.getEntryDate());
        journalEntry.setReference(request.getReference());
        journalEntry.setDescription(request.getDescription());

        // Clear existing lines and create new ones
        journalEntry.getLines().clear();

        List<JournalEntryLine> lines = new ArrayList<>();
        BigDecimal totalDebit = BigDecimal.ZERO;
        BigDecimal totalCredit = BigDecimal.ZERO;

        for (var lineRequest : request.getLines()) {
            Account account = accountRepository.findByIdAndOrganizationId(lineRequest.getAccountId(), orgId)
                    .orElseThrow(() -> new ResourceNotFoundException("Account not found: " + lineRequest.getAccountId()));

            JournalEntryLine line = JournalEntryLine.builder()
                    .journalEntry(journalEntry)
                    .account(account)
                    .description(lineRequest.getDescription())
                    .debitAmount(lineRequest.getDebitAmount() != null ? lineRequest.getDebitAmount() : BigDecimal.ZERO)
                    .creditAmount(lineRequest.getCreditAmount() != null ? lineRequest.getCreditAmount() : BigDecimal.ZERO)
                    .lineOrder(lineRequest.getLineOrder())
                    .build();

            lines.add(line);
            totalDebit = totalDebit.add(line.getDebitAmount());
            totalCredit = totalCredit.add(line.getCreditAmount());
        }

        journalEntry.setLines(lines);
        journalEntry.setTotalDebit(totalDebit);
        journalEntry.setTotalCredit(totalCredit);

        // Validate double entry
        validateDoubleEntry(journalEntry);

        journalEntry = journalEntryRepository.save(journalEntry);
        return mapToResponse(journalEntry);
    }

    @Transactional
    public JournalEntryResponse postJournalEntry(Long id) {
        Long orgId = SecurityUtils.getCurrentOrganizationId();
        JournalEntry journalEntry = journalEntryRepository.findByIdAndOrganizationId(id, orgId)
                .orElseThrow(() -> new ResourceNotFoundException("Journal entry not found"));

        // Only allow posting DRAFT entries
        if (journalEntry.getStatus() != JournalEntryStatus.DRAFT) {
            throw new BusinessException("Only DRAFT journal entries can be posted");
        }

        // Validate double entry before posting
        validateDoubleEntry(journalEntry);

        // Update account balances
        for (JournalEntryLine line : journalEntry.getLines()) {
            Account account = line.getAccount();
            BigDecimal currentBalance = account.getCurrentBalance();

            // Update balance based on account type and debit/credit
            BigDecimal newBalance = calculateNewBalance(account, line.getDebitAmount(), line.getCreditAmount());
            account.setCurrentBalance(newBalance);
            accountRepository.save(account);
        }

        // Update status to POSTED
        journalEntry.setStatus(JournalEntryStatus.POSTED);
        journalEntry = journalEntryRepository.save(journalEntry);

        return mapToResponse(journalEntry);
    }

    @Transactional
    public JournalEntryResponse reverseJournalEntry(Long id) {
        Long orgId = SecurityUtils.getCurrentOrganizationId();
        JournalEntry originalEntry = journalEntryRepository.findByIdAndOrganizationId(id, orgId)
                .orElseThrow(() -> new ResourceNotFoundException("Journal entry not found"));

        // Only allow reversing POSTED entries
        if (originalEntry.getStatus() != JournalEntryStatus.POSTED) {
            throw new BusinessException("Only POSTED journal entries can be reversed");
        }

        // Mark original entry as REVERSED
        originalEntry.setStatus(JournalEntryStatus.REVERSED);
        journalEntryRepository.save(originalEntry);

        // Create reversing entry
        String reversingJournalNumber = generateReversingJournalNumber(originalEntry.getJournalNumber());

        JournalEntry reversingEntry = JournalEntry.builder()
                .organization(originalEntry.getOrganization())
                .journalNumber(reversingJournalNumber)
                .entryDate(LocalDate.now())
                .status(JournalEntryStatus.DRAFT)
                .reference("Reversal of " + originalEntry.getJournalNumber())
                .description("Reversing entry for: " + originalEntry.getDescription())
                .isAutoGenerated(true)
                .build();

        // Create reversed lines (swap debit and credit)
        List<JournalEntryLine> reversingLines = new ArrayList<>();
        BigDecimal totalDebit = BigDecimal.ZERO;
        BigDecimal totalCredit = BigDecimal.ZERO;

        for (JournalEntryLine originalLine : originalEntry.getLines()) {
            JournalEntryLine reversingLine = JournalEntryLine.builder()
                    .journalEntry(reversingEntry)
                    .account(originalLine.getAccount())
                    .description("Reversal: " + originalLine.getDescription())
                    .debitAmount(originalLine.getCreditAmount()) // Swap credit to debit
                    .creditAmount(originalLine.getDebitAmount()) // Swap debit to credit
                    .lineOrder(originalLine.getLineOrder())
                    .build();

            reversingLines.add(reversingLine);
            totalDebit = totalDebit.add(reversingLine.getDebitAmount());
            totalCredit = totalCredit.add(reversingLine.getCreditAmount());
        }

        reversingEntry.setLines(reversingLines);
        reversingEntry.setTotalDebit(totalDebit);
        reversingEntry.setTotalCredit(totalCredit);

        // Validate and save the reversing entry
        validateDoubleEntry(reversingEntry);
        reversingEntry = journalEntryRepository.save(reversingEntry);

        // Automatically post the reversing entry
        return postJournalEntry(reversingEntry.getId());
    }

    @Transactional
    public void deleteJournalEntry(Long id) {
        Long orgId = SecurityUtils.getCurrentOrganizationId();
        JournalEntry journalEntry = journalEntryRepository.findByIdAndOrganizationId(id, orgId)
                .orElseThrow(() -> new ResourceNotFoundException("Journal entry not found"));

        // Only allow deleting DRAFT entries
        if (journalEntry.getStatus() != JournalEntryStatus.DRAFT) {
            throw new BusinessException("Cannot delete journal entry that is not in DRAFT status");
        }

        journalEntryRepository.delete(journalEntry);
    }

    /**
     * Validates that total debits equal total credits (double-entry bookkeeping rule)
     */
    private void validateDoubleEntry(JournalEntry journalEntry) {
        if (journalEntry.getTotalDebit().compareTo(journalEntry.getTotalCredit()) != 0) {
            throw new BusinessException(
                    String.format("Journal entry is not balanced. Total Debit: %s, Total Credit: %s",
                            journalEntry.getTotalDebit(), journalEntry.getTotalCredit())
            );
        }
    }

    /**
     * Calculates new account balance based on account type and transaction amounts
     */
    private BigDecimal calculateNewBalance(Account account, BigDecimal debitAmount, BigDecimal creditAmount) {
        BigDecimal currentBalance = account.getCurrentBalance();

        switch (account.getAccountType()) {
            case ASSET:
            case EXPENSE:
                // Debit increases, Credit decreases
                return currentBalance.add(debitAmount).subtract(creditAmount);

            case LIABILITY:
            case EQUITY:
            case REVENUE:
                // Credit increases, Debit decreases
                return currentBalance.add(creditAmount).subtract(debitAmount);

            default:
                throw new BusinessException("Unknown account type: " + account.getAccountType());
        }
    }

    /**
     * Generates a unique journal number for reversing entries
     */
    private String generateReversingJournalNumber(String originalJournalNumber) {
        String baseNumber = "REV-" + originalJournalNumber;
        String reversingNumber = baseNumber;
        int counter = 1;

        Long orgId = SecurityUtils.getCurrentOrganizationId();
        while (journalEntryRepository.existsByJournalNumberAndOrganizationId(reversingNumber, orgId)) {
            reversingNumber = baseNumber + "-" + counter;
            counter++;
        }

        return reversingNumber;
    }

    private JournalEntryResponse mapToResponse(JournalEntry journalEntry) {
        List<JournalEntryResponse.JournalEntryLineResponse> lineResponses = journalEntry.getLines().stream()
                .map(line -> JournalEntryResponse.JournalEntryLineResponse.builder()
                        .id(line.getId())
                        .accountId(line.getAccount().getId())
                        .accountCode(line.getAccount().getCode())
                        .accountName(line.getAccount().getName())
                        .description(line.getDescription())
                        .debitAmount(line.getDebitAmount())
                        .creditAmount(line.getCreditAmount())
                        .lineOrder(line.getLineOrder())
                        .build())
                .collect(Collectors.toList());

        return JournalEntryResponse.builder()
                .id(journalEntry.getId())
                .journalNumber(journalEntry.getJournalNumber())
                .entryDate(journalEntry.getEntryDate())
                .status(journalEntry.getStatus())
                .reference(journalEntry.getReference())
                .description(journalEntry.getDescription())
                .totalDebit(journalEntry.getTotalDebit())
                .totalCredit(journalEntry.getTotalCredit())
                .isAutoGenerated(journalEntry.getIsAutoGenerated())
                .lines(lineResponses)
                .createdAt(journalEntry.getCreatedAt())
                .updatedAt(journalEntry.getUpdatedAt())
                .build();
    }
}
